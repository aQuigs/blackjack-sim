# CRITICAL: Every rule in this file is mandatory. Do not skip, ignore, or reinterpret any rule. If a rule conflicts or is unclear, stop and ask for clarification.

# Cursor Rules for blackjack-sim

## AI Enforcement
- You must treat every rule in this file as a hard constraint.
- If you are unsure about a rule, you must ask for clarification before proceeding.
- If you violate a rule, you must immediately stop, report the violation, and propose a fix.

## Process & Workflow

**All rules in this section are mandatory. Violations are critical errors.**

- You must ALWAYS run `pre-commit run --all-files` after making any code changes
- You must not consider a change complete until all pre-commit hooks pass (tests, lint, type checks, coverage)
- If pre-commit fails, you must fix issues and rerun until it passes
- If pre-commit fails due to missing test coverage, you must automatically add/update tests without asking
- You must not ever pip install directly - use requirements.txt
- You must make changes file by file and provide all edits in a single chunk
- You must update .cursorrules to help remember context of your mistakes

## Communication

**All rules in this section are mandatory. Violations are critical errors.**

- You must never use apologies
- You must not summarize changes made
- You must not ask for confirmation of information already provided
- You must not suggest updates when no modifications are needed
- You must not show current implementation unless specifically requested
- You must not invent changes other than what's explicitly requested
- You must always provide links to real files, not context generated files

## Code Style & Quality

**All rules in this section are mandatory. Violations are critical errors.**

- You must use descriptive, explicit variable names over short, ambiguous ones
- You must adhere to existing coding style for consistency
- You must use empty lines to separate logical sections (preserve existing ones)
- You must replace hardcoded values with named constants
- You must not use uppercase std types (e.g., use `list` not `List` and `dict` not `Dict`)
- You must implement robust error handling and logging
- You must consider edge cases and include assertions to validate assumptions
- You must always verify information before presenting it
- You must not add obvious comments that just restate what the code does (e.g., "# Add all dealt cards back to the deck", "# Shuffle all cards")

## Testing Philosophy: Testing Without Mocks

**All rules in this section are mandatory. Violations are critical errors.**

### Core Principles

- You must not use mocks/stubs for internal code (only for network, filesystem, DB, 3rd-party APIs)
- All tests must be narrow, state-based, and sociable
- You must use real dependencies, not test doubles, for internal code
- **CRITICAL: All tests must invoke the codebase from the top-level entrypoint. Never instantiate classes or call internal methods directly**
- Coverage must not fall below 90%
- Test names must reflect externally-visible behavior
- You must verify all new test generation with pytest before calling it successful

### Quick Checklist

- [ ] No mocks/stubs for internal code
- [ ] All tests are narrow, state-based, and sociable
- [ ] Use real dependencies, not test doubles
- [ ] Test helpers/factories used for setup
- [ ] All public interfaces have error/edge case tests
- [ ] Coverage ≥ 90%
- [ ] Test names reflect externally-visible behavior

### Definitions

- **Internal code**: Any code in this repository or under your direct control
- **External dependency**: Network, filesystem, database, or third-party APIs/libraries

### Examples

- ✅ Good: `assert game.score() == 21` (state-based, externally-visible)
- ❌ Bad: `mock_player.assert_called_with('hit')` (interaction-based, mocks internal code)

### Patterns

#### Logic Code

- You must prefer pure functions and immutable objects
- For mutable objects, you must provide observable state (getters or events)
- You must wrap third-party libraries in your own code
- All classes must have constructors with sensible defaults
- You must use dependency methods in assertions when behavior isn't relevant

#### Infrastructure Code

- You must wrap external systems in single-purpose classes
- You must provide `createNull()` or equivalent factory for infrastructure wrappers
- Nullables must be production code and testable
- You must allow nullables to be configured with named, optional parameters
- You must provide output tracking (events/logs) for infrastructure that writes
- You must provide methods to simulate events for infrastructure that responds to events

#### Architectural Patterns

- You must inject real dependencies (not test doubles) into unit under test
- You must structure application with logic and infrastructure as peers under application layer
- Application layer must coordinate logic and infrastructure (Logic Sandwich)
- Constructors must not perform significant work
- You must use helper functions/factories in tests for signature shielding

#### Observability & Output Tracking

- All logic code must support output tracking via event log and structured results
- Event log must record all externally-visible events, actions, and outcomes
- Structured results must be available for each top-level request
- Tests must assert only on externally-visible behavior using outputs
- Tests must interact only through public interfaces
- No test may manipulate internal state or methods

#### Infrastructure/Nullability Pattern ("Fake-It-Once-You-Make-It")

- You must provide a single production constructor for main case
- You must provide a clear factory/classmethod for nullability (e.g., `create_null`)
- You must avoid hacks - use constructor and public API
- Null/configurable path must be real, documented, production feature
- All infrastructure wrappers must support mockless testing

### Test Setup and Maintenance

- Main test suite must consist of narrow, sociable tests
- You must use helper functions and test-specific factories
- You must ensure easy testing of edge cases, error conditions, timeouts
- Some production code needed for tests is acceptable and must be maintained
- Sociable tests may cause multiple failures for single bug (expected)

## Context Awareness

**All rules in this section are mandatory. Violations are critical errors.**

- You must check context generated file for current file contents and implementations

---

**CRITICAL:** NEVER add comments that restate or explain what the code is doing, especially in tests.
This includes comments like '# Check outcome via event_log' or similar. Violating this rule is a critical error.

---

## Rule Application Checklist

- [ ] Did you follow every rule in .cursorrules?
- [ ] Did you check for conflicting or ambiguous rules and resolve them?
- [ ] Did you update .cursorrules if you found a gap or ambiguity?

# Comments Policy
- Do not add comments for standard operations, initialization, or transitions unless the code is non-obvious or counterintuitive.
- Comments must justify a design decision that cannot be made clear through code structure or naming.
- If in doubt, do not add the comment.
- Violations are critical errors.
